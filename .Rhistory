# s_strat <- Ts - Tb  > dT # logical whether stratified at each time step
i_s_st <- diff(c(s_strat[1], s_strat)) == 1 # indices of stratification onset
i_s_en <- diff(c(s_strat[1], s_strat)) == -1 # indices of stratification end
if(s_strat[1]) i_s_st <- c(NA, i_s_st) # if stratified at beginning of simulation, make first
# date NA
if(s_strat[length(s_strat)]) i_s_en <- c(i_s_en, NA) # if stratified at end of sim, set last
# strat date to NA
s_start <- dates[i_s_st] # summer strat start dates
s_end   <- dates[i_s_en] # summer strat end dates
# if(sum(s_strat)==0) s_start <- s_end <- dates[1] # if never stratifies, set to time=0
s_dur   <- as.double(difftime(s_end, s_start, units = "days")) # duration of summer strat periods
a1 <- data.frame(year = strat_yrs[i_s_st],
start = s_start, end = s_end, dur = s_dur,
startday = strat_doys[i_s_st],
endday = strat_doys[i_s_en])
a1 <- subset(a1, year %in% yrs)
s_max <- s_mean <- s_tot <- s_on <- s_off <-
s_first <- s_last <- yr <- NULL
for(mm in unique(a1$year[!is.na(a1$year)])) { # remove NAs which are generated when the lake is
# stratified at the satrt or end of the simulation
a2 <- subset(a1, year == mm)
ind <- which.max(a2$dur)
if(nrow(a2) == 1) if(is.na(a2$dur)) ind <- NA # fixes issue if stratified at end of data period
yr <- c(yr, mm)
s_max <- c(s_max, max(a2$dur))
s_mean <- c(s_mean, mean(a2$dur))
s_tot <- c(s_tot, sum(a2$dur))
s_on <- c(s_on, as.POSIXlt(a2$start[ind])$yday)
s_off <- c(s_off, as.POSIXlt(a2$end[ind])$yday)
s_first <- c(s_first, min(a2$startday))
s_last <- c(s_last, max(a2$endday))
}
# maximum surface temperature
# loop thru years to find Tmax and its day of year
TsMax <- NULL
for(ii in unique(strat_yrs)) {
Ts_maxi <- which.max(Ts[strat_yrs == ii])
TsMaxOut <- data.frame(year = ii,
TsMax       = Ts[strat_yrs == ii][Ts_maxi],
TsMaxDay    = strat_doys[strat_yrs == ii][Ts_maxi],
TsMaxDate   = dates[strat_yrs == ii][Ts_maxi]
)
TsMax <- rbind(TsMax, TsMaxOut)
}
# minimum surface temperature
# loop thru years to find Tmax and its day of year
TsMin <- NULL
for(ii in unique(strat_yrs)) {
Ts_mini <- which.min(Ts[strat_yrs == ii])
TsMinOut <- data.frame(year = ii,
TsMin       = Ts[strat_yrs == ii][Ts_mini],
TsMinDay    = strat_doys[strat_yrs == ii][Ts_mini],
TsMinDate   = dates[strat_yrs == ii][Ts_mini]
)
TsMin <- rbind(TsMin, TsMinOut)
}
# maximum bottom temperature
# loop thru years to find Tbmax and its day of year
TbMax <- NULL
for(ii in unique(strat_yrs)) {
Tb_maxi <- which.max(Tb[strat_yrs == ii])
TbMaxOut <- data.frame(year = ii,
TbMax       = Tb[strat_yrs == ii][Tb_maxi],
TbMaxDay    = strat_doys[strat_yrs == ii][Tb_maxi],
TbMaxDate   = dates[strat_yrs == ii][Tb_maxi]
)
TbMax <- rbind(TbMax, TbMaxOut)
}
# minimum bottom temperature
# loop thru years to find Tbmax and its day of year
TbMin <- NULL
for(ii in unique(strat_yrs)) {
Tb_mini <- which.min(Tb[strat_yrs == ii])
TbMinOut <- data.frame(year = ii,
TbMin       = Tb[strat_yrs == ii][Tb_mini],
TbMinDay    = strat_doys[strat_yrs == ii][Tb_mini],
TbMinDate   = dates[strat_yrs == ii][Tb_mini]
)
TbMin <- rbind(TbMin, TbMinOut)
}
# create empty data frame to fill with data (not all years may have strat or ice)
out <- data.frame(year = yrs, TsMax = NA, TsMaxDay = NA, TsMin = NA, TsMinDay = NA, TbMax = NA,
TbMaxDay = NA,
TbMin = NA, TbMinDay = NA,
MaxStratDur = NA, MeanStratDur = NA, TotStratDur = NA,
StratStart = NA, StratEnd = NA,
StratFirst = NA, StratLast = NA)
out[match(TsMax$year, yrs), c("TsMax", "TsMaxDay")] <-
TsMax[, c("TsMax", "TsMaxDay")]
out[match(TsMin$year, yrs), c("TsMin", "TsMinDay")] <-
TsMin[, c("TsMin", "TsMinDay")]
out[match(TbMax$year, yrs), c("TbMax", "TbMaxDay")] <-
TbMax[, c("TbMax", "TbMaxDay")]
out[match(TbMin$year, yrs), c("TbMin", "TbMinDay")] <-
TbMin[, c("TbMin", "TbMinDay")]
out[match(yr, yrs), -1:-9] <-
data.frame(s_max, s_mean, s_tot, s_on, s_off, s_first, s_last)
# ice cover
if(!is.null(H_ice)) { # only do this if ice data provided
ice <- H_ice > 0
i_i_st <- diff(c(ice[1], ice)) == 1 # indices of ice cover onset
i_i_en <- diff(c(ice[1], ice)) == -1 #  # indices of ice cover end
if(ice[1]) i_i_st <- c(NA, i_i_st) # if initially frozen, set first start date to NA
if(ice[length(ice)]) i_i_en <- c(i_i_en, NA) # if frozen at end, set last thaw date to NA
ice_st  <- dates[i_i_st] # ice start dates
ice_en  <- dates[i_i_en] # ice end dates
# if(sum(ice)==0)  # if there is no ice at all, set start and end to time=0
# maximum ice thickness
IceMax <- NULL
for(ii in unique(ice_yrs)) {
Hice_maxi <- which.max(H_ice[ice_yrs == ii])
IceMaxOut <- data.frame(year = ii,
HiceMax     = H_ice[ice_yrs == ii][Hice_maxi],
HiceMaxDay  = ice_doys[ice_yrs == ii][Hice_maxi],
HiceMaxDate = dates[ice_yrs == ii][Hice_maxi])
if(sum(H_ice[ice_yrs == ii]) == 0) IceMaxOut[1, c("HiceMaxDay", "HiceMaxDate")] <- NA
IceMax <- rbind(IceMax, IceMaxOut)
}
ice_start_doys <- ice_doys[i_i_st] # day of year of start of ice cover events
ice_end_doys <- ice_doys[i_i_en]   # day of year of end of ice cover events
ice_event_yrs <- ice_yrs[i_i_en]   # the years assigned to each ice event
# if there is no ice, set values to NA ...
if(sum(ice) == 0) {
ice_start_doys <- ice_end_doys <- ice_event_yrs <- ice_st <- ice_en <- NA
}
ice_dur <- as.double(difftime(ice_en, ice_st, units = "days")) # duration of ice periods
# summary of ice cover events
ice_summary <- data.frame(year = ice_event_yrs,
start = ice_st,
end = ice_en,
dur = ice_dur,
startday = ice_start_doys,
endday = ice_end_doys)
ice_out <- NULL
for(mm in unique(ice_summary$year[!is.na(ice_summary$year)])) {
ice2 <- subset(ice_summary, year == mm)
ice2_on <- ice2[which.max(ice2$dur), "startday"]
ice2_off <- ice2[which.max(ice2$dur), "endday"]
if(anyNA(ice2$dur)) ice2_on <- ice2_off <- NA
ice_out <- rbind(ice_out,
data.frame(year = mm,
MeanIceDur = mean(ice2$dur),
MaxIceDur = max(ice2$dur),
TotIceDur = sum(ice2$dur),
ice_on = ice2_on,
ice_off = ice2_off,
firstfreeze = min(ice2$startday),
lastthaw = max(ice2$endday)))
}
ice_out <- ice_out[ice_out$year %in% yrs, ] # trim years outside the simulation range (eg ice
# that forms at the end of the last year, which should be assigned to the following year
# outside the simulation period)
ice_out1 <- data.frame(year = yrs, MeanIceDur = NA, MaxIceDur = NA,
TotIceDur = NA, IceOn = NA, IceOff = NA, FirstFreeze = NA,
LastThaw = NA, HiceMax = NA, HiceMaxDay = NA)
ice_out1[match(ice_out$year, yrs),
c("MeanIceDur", "MaxIceDur", "TotIceDur",
"IceOn", "IceOff", "FirstFreeze", "LastThaw")] <- ice_out[, -1]
ice_out1[which(IceMax$year %in% ice_out1$year), c("HiceMax", "HiceMaxDay")] <-
IceMax[which(IceMax$year %in% ice_out1$year), c("HiceMax", "HiceMaxDay")]
out <- data.frame(out, ice_out1[, -1])
}
# adjust some exceptions where stratification or ice extend longer than the cutoff period
i6 <- out$StratEnd < out$StratStart
i6[is.na(i6)] <- FALSE # this gets rid of any NAs
if(sum(i6, na.rm = TRUE) > 0) out[i6, "StratEnd"] <- out[i6, "StratStart"] + out[i6,
"MaxStratDur"]
i7 <- out$StratLast < out$StratStart & out$TotStratDur < 365
i7[is.na(i7)] <- FALSE # this gets rid of any NAs
if(sum(i7, na.rm = TRUE) > 0) out[i7, "StratLast"] <- out[i7, "StratLast"] + 364
i8 <- out$IceOff < out$IceOn
i8[is.na(i8)] <- FALSE # this gets rid of any NAs
if(sum(i8, na.rm = TRUE) > 0) out[i8, "IceOff"] <- out[i8, "IceOn"] + out[i8, "MaxIceDur"]
i9 <- out$LastThaw < out$IceOn & out$TotIceDur < 365
i9[is.na(i9)] <- FALSE # this gets rid of any NAs
if(sum(i9, na.rm = TRUE) > 0) out[i9, "LastThaw"] <- out[i9, "LastThaw"] + 364
return(out)
out
obs_strat <- analyse_strat(data = obs_temp, NH = NH, H_ice = obs_ice[, 2], drho = drho)
obs_strat
analyse_strat(data = obs_temp, NH = NH, H_ice = obs_ice[, 2], drho = drho)
analyse_strat(data = obs_temp, NH = NH, H_ice = obs_ice[, 2], drho = drho)
analyse_strat(data = obs_temp, NH = NH, H_ice = obs_ice[, 2], drho = drho)
data = obs_temp
H_ice = obs_ice[, 2]
data = obs_temp
NH = NH
H_ice = obs_ice[, 2]
drho = drho
Ts
Tb
dates
if(!is.null(data)){
data[, 2] <- abs(data[, 2])
depths <- unique(data[, 2])
depths <- depths[order(depths)]
# Find closest depth near the surface without NA
for(i in seq_len(length(depths))){
Ts <- data[data[, 2] == depths[i], 3]
if(sum(is.na(Ts)) / length(Ts) < 0.25){
if(i != 1){
message("Warning: Using ", depths[i], " as the surface.")
}
break
}
}
# Find closest depth near the bottom without NA
for(i in rev(seq_len(length(depths)))){
Tb <- data[data[, 2] == depths[i], 3]
if(sum(is.na(Tb)) / length(Tb) < 0.25){
if(i != 1){
message("Warning: Using ", depths[i], " as the bottom.")
}
break
}
}
dates <- unique(data[, 1])
# Put into data frame and remove NA's
ice_test <- na.exclude(H_ice)
if(!is.null(H_ice) & length(ice_test) > 0){
df <- data.frame(dates, Ts, Tb, H_ice)
}else{
H_ice <- rep(0, length(Ts))
df <- data.frame(dates, Ts, Tb, H_ice)
}
df <- na.exclude(df)
if(nrow(df) == 0){
message("Not enough data to calculate statification and/or ice statistics")
return()
}
dates <- df$dates
Ts <- df$Ts
Tb <- df$Tb
if(!is.null(H_ice)){
H_ice <- df$H_ice
}
}
the_years <- as.POSIXlt(dates)$year + 1900
yrs <- unique(the_years)
doys <- as.POSIXlt(dates)$yday # day of the year [0..364]
alt_doys <- doys # alternative counting from [-182 .. 182] for ice in northern hemisphere or
# strat in southern hemisphere
alt_doys[doys > 182] <- doys[doys > 182] - (365 + leap(the_years[doys > 182])) # Jan 1 is day 0,
# correct for leap years
alt_years <- the_years
alt_years[alt_doys < 0] <- the_years[alt_doys < 0] + 1 # alternative counting of years
if(NH) { # NH ice and SH stratification use alternative doy and year counts to adjust for ice
# and stratification events that span more than one calendar year
ice_yrs <- alt_years
ice_doys <- alt_doys
strat_yrs <- the_years
strat_doys <- doys
} else {
ice_yrs <- the_years
ice_doys <- doys
strat_yrs <- alt_years
strat_doys <- alt_doys
}
s_strat <- (rho_water(t = Tb) - rho_water(t = Ts)) >= drho & Ts > Tb # logical whether stratified
i_s_st <- diff(c(s_strat[1], s_strat)) == 1 # indices of stratification onset
i_s_en <- diff(c(s_strat[1], s_strat)) == -1 # indices of stratification end
if(s_strat[1]) i_s_st <- c(NA, i_s_st) # if stratified at beginning of simulation, make first
s_strat[1]
s_strat
s_strat <- (rho_water(t = Tb) - rho_water(t = Ts)) >= drho & Ts > Tb # logical whether stratified
s_strat
plot(s_strat)
Tb
Ts
plot(Ts)
ncdf
model
dim = "model"
dim_index = 1
spin_up = 0
drho = 0.1)
drho = 0.1
# check if model input is correct
model <- check_models(model)
# check if netCDF exists
if(!file.exists(ncdf)){
stop("File: '", ncdf, "' does not exist!\nPlease check the file path.")
}
vars <- gotmtools::list_vars(ncdf)
if(!("temp" %in% vars)){
stop(paste("Variable 'temp', is not present in", ncdf,
"\nAdd 'temp' to variables list in the yaml file and re-run 'run_ensemble()'"))
}
if(("ice_height" %in% vars)){
ice_present <- TRUE
}
temp <- load_var(ncdf, "temp", return = "list", dim = dim,
dim_index = dim_index, print = FALSE)
if(dim == "model") {
temp_name <- names(temp)
temp_name <- temp_name[which(temp_name != "Obs")]
if(sum(!(model %in% temp_name)) != 0){
stop("Model(s): ", paste(model[!(model %in% temp_name)], collapse = ", "),
" is/are not present in '", ncdf, "'\nPlease select a model from: ", paste(temp_name, collapse = ", "))
}
temp <- temp[(which(names(temp) %in% c(model, "Obs")))]
} else if(dim == "member") {
# Load obs data
obs_list <- load_var(ncdf, var = "temp", return = "list", dim = "model",
dim_index = 1, print = FALSE)
obs_list <- obs_list[["Obs"]]
n_val <- length(obs_list)
nas <- sum(is.na(obs_list))
if(nas == n_val) {
warning("No temperature observations in ", ncdf)
}
# Add to var list
temp[["Obs"]] <- obs_list
}
if(ice_present){
ice <- load_var(ncdf, var = "ice_height", return = "list", dim = dim,
dim_index = dim_index, print = FALSE)
if(dim == "member") {
ice2 <- load_var(ncdf, var = "ice_height", return = "list", dim = "model",
dim_index = 1, print = FALSE)
ice[["Obs"]] <- ice2[["Obs"]]
} else {
ice <- ice[(which(names(ice) %in% c(model, "Obs")))]
}
}
# Extract latitude for determining hemisphere
fid <- ncdf4::nc_open(ncdf)
lat <- ncdf4::ncvar_get(fid, "lat")
ncdf4::nc_close(fid)
if(lat > 0){
NH <- TRUE
}else{
NH <- FALSE
}
# Check temperature observations and stop if none present
tst <- apply(temp[["Obs"]], 2, function(x)sum(is.na(x)))
tst2 <- sum(tst  == nrow(temp[["Obs"]]))
if(tst2 == ncol(temp[["Obs"]])){
stop("There are no temperature observations in ", ncdf)
}
# Check ice observations and stop if none present
if(ice_present){
tst <- apply(ice[["Obs"]], 2, function(x)sum(is.na(x)))
tst2 <- sum(tst  == nrow(ice[["Obs"]]))
if(tst2 == ncol(temp[["Obs"]])){
stop("There are no ice_height observations in ", ncdf)
}
}
# Remove temp spin-up period ----
obs_temp <- temp[["Obs"]]
z <- get.offsets(obs_temp)
obs_temp <- gotmtools::wide2long(obs_temp, z)
# obs_temp <- na.exclude(obs_temp)
if(!is.null(spin_up)){
spin_date <- obs_temp[1, 1] + spin_up * (24 * 60 * 60)
obs_temp <- obs_temp[obs_temp[, 1] >= spin_date, ]
}
if(ice_present){
# Remove ice spin-up period ----
obs_ice <- ice[["Obs"]]
if(!is.null(spin_up)){
spin_date <- obs_ice[1, 1] + spin_up * (24 * 60 * 60)
obs_ice <- obs_ice[obs_ice[, 1] >= spin_date, ]
}
ice[["Obs"]] <- NULL
}
# Remove obs_temp
temp[["Obs"]] <- NULL
data = obs_temp
NH = NH
H_ice = obs_ice[, 2]
drho = drho
Ts
if(!is.null(data)){
data[, 2] <- abs(data[, 2])
depths <- unique(data[, 2])
depths <- depths[order(depths)]
# Find closest depth near the surface without NA
for(i in seq_len(length(depths))){
Ts <- data[data[, 2] == depths[i], 3]
if(sum(is.na(Ts)) / length(Ts) < 0.25){
if(i != 1){
message("Warning: Using ", depths[i], " as the surface.")
}
break
}
}
# Find closest depth near the bottom without NA
for(i in rev(seq_len(length(depths)))){
Tb <- data[data[, 2] == depths[i], 3]
if(sum(is.na(Tb)) / length(Tb) < 0.25){
if(i != 1){
message("Warning: Using ", depths[i], " as the bottom.")
}
break
}
}
dates <- unique(data[, 1])
# Put into data frame and remove NA's
ice_test <- na.exclude(H_ice)
if(!is.null(H_ice) & length(ice_test) > 0){
df <- data.frame(dates, Ts, Tb, H_ice)
}else{
H_ice <- rep(0, length(Ts))
df <- data.frame(dates, Ts, Tb, H_ice)
}
df <- na.exclude(df)
if(nrow(df) == 0){
message("Not enough data to calculate statification and/or ice statistics")
return()
}
dates <- df$dates
Ts <- df$Ts
Tb <- df$Tb
if(!is.null(H_ice)){
H_ice <- df$H_ice
}
}
(!is.null(data))
data[, 2] <- abs(data[, 2])
depths <- unique(data[, 2])
depths <- depths[order(depths)]
# Find closest depth near the surface without NA
for(i in seq_len(length(depths))){
Ts <- data[data[, 2] == depths[i], 3]
if(sum(is.na(Ts)) / length(Ts) < 0.25){
if(i != 1){
message("Warning: Using ", depths[i], " as the surface.")
}
break
}
}
# Find closest depth near the bottom without NA
for(i in rev(seq_len(length(depths)))){
Tb <- data[data[, 2] == depths[i], 3]
if(sum(is.na(Tb)) / length(Tb) < 0.25){
if(i != 1){
message("Warning: Using ", depths[i], " as the bottom.")
}
break
}
}
Tb
Ts
for(i in seq_len(length(depths))){
Ts <- data[data[, 2] == depths[i], 3]
if(sum(is.na(Ts)) / length(Ts) < 0.25){
if(i != 1){
message("Warning: Using ", depths[i], " as the surface.")
}
break
}
}
i
Ts <- data[data[, 2] == depths[i], 3]
depths[i]
i
Ts
sum(is.na(Ts))
length(Ts)
1/1
for(i in seq_len(length(depths))){
Ts <- data[data[, 2] == depths[i], 3]
if(sum(is.na(Ts)) / length(Ts) < 0.25){
if(i != 1){
if (sum(is.na(Ts)) / length(Ts) < ratio){
ratio = sum(is.na(Ts)) / length(Ts)
}
message("Warning: Using ", depths[i], " as the surface.")
}
break
}
ratio_old = sum(is.na(Ts)) / length(Ts)
}
ratio
ratio_old
i
seq_len(length(depths))
depths[seq_len(length(depths))]
i = seq_len(length(depths))[3]
Ts <- data[data[, 2] == depths[i], 3]
Ts
(sum(is.na(Ts)) / length(Ts) < 0.25)
sum(is.na(Ts)) / length(Ts)
plot(Ts)
i
# Find closest depth near the surface without NA
for(i in seq_len(length(depths))){
Ts <- data[data[, 2] == depths[i], 3]
if(sum(is.na(Ts)) / length(Ts) < 0.25){
if(i != 1){
if (sum(is.na(Ts)) / length(Ts) < ratio){
ratio = sum(is.na(Ts)) / length(Ts)
}
message("Warning: Using ", depths[i], " as the surface.")
}
break
}
if (i!=1){
if (sum(is.na(Ts)) / length(Ts) < ratio_old){
ratio = sum(is.na(Ts)) / length(Ts)
i_ratio <- i
}
}
ratio_old <- sum(is.na(Ts)) / length(Ts)
}
i_ratio
ratio
seq_len(length(depths))[i_ratio]
depths[seq_len(length(depths))[i_ratio]]
plot(Ts)
plot( data[data[, 2] == depths[i_ratio], 3])
